The benchmarks.rb file appears under a section named “Changed but not updated” — which means that a file that

is tracked has been modified in the working directory but not yet staged. To stage it, you run the git add command

Just keep in mind:

git add is a multipurpose command — you use it to begin tracking new

files, to stage files, and to do other things like marking merge-conflicted files as resolved!!!

If you modify a file after you run git add, you have to run git add again to stage the latest version of the file.

To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it
from your staging area) and then commit. The git rm command does that and also removes the file
from your working directory so you don’t see it as an untracked file next time around.

If you simply remove the file from your working directory(just use rm filename, but not git rm

filename),it shows up under the “Changed but not updated” (that is, unstaged) area of your git status 

output,Then, but you run git rm filename, it stages the file’s removal, means remove file from hard disk 

also from git(staging area)

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging 

area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore.

$ git rm --cached readme.txt  (it is very useful)

You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as
$ git rm log/\*.log  (the \ is necessary)
This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this: $ git rm \*~   This command removes all files that end with ~.

If you want to rename a file in Git, you can run something like $ git mv file_from file_to.
this is equivalent to running something like this: $ mv README.txt README $ git rm README.txt $ git add README

use git clone http://github.com/schacon/simplegit-progit.git  to get the simplegit project to check log.

Show ming how to use simplegit tool.(such as -p, -2 options)

As an example, if you commit and then realize you forgot to stage the changes in a file you wanted to
add to this commit, you can do something like this:
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
All three of these commands end up with a single commit — the second commit replaces the results of
the first.

If you clone a repository, the command automatically adds that remote repository under the name
origin. So, git fetch origin fetches any new work that has been pushed to that server since you
cloned (or last fetched from) it. It’s important to note that the fetch command pulls the data to your
local repository — it doesn’t automatically merge it with any of your work or modify what you’re
currently working on. You have to merge it manually into your work when you’re ready.

If you have a branch set up to track a remote branch,you can use the git pull command to automatically fetch and then merge a remote
branch into your current branch. This may be an easier or more comfortable workflow for you; and by
default, the git clone command automatically sets up your local master branch to track the remote
master branch on the server you cloned from (assuming the remote has a master branch). Running
git pull generally fetches data from the server you originally cloned from and automatically tries to
merge it into the code you’re currently working on.